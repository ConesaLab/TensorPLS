% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Array3DCreation.R, R/ChooseCreation.R,
%   R/Read.R, R/Transposition.R
\name{create_array3d}
\alias{create_array3d}
\alias{.build_tensor}
\alias{.read_or_pass}
\alias{.transpose_if_needed}
\title{Build a 3-D numeric array (subjects × features × time)}
\usage{
create_array3d(
  df,
  id_col,
  time_col,
  feature_cols = NULL,
  exclude_cols = c(id_col, time_col),
  subjects = NULL,
  time_points = NULL,
  legacy_na = FALSE,
  deduplicate = c("first", "last", "mean")
)

.build_tensor(df, id_col, time_col = NULL, ..., legacy_na = FALSE)

.read_or_pass(x)

.transpose_if_needed(
  df,
  mode = c("auto", "never", "always"),
  header_in_row = TRUE
)
}
\arguments{
\item{df}{A data.frame to be examined and possibly transposed.}

\item{id_col}{Name of the subject-identifier column.}

\item{time_col}{Optional; if \code{NULL} or not found in \code{df}, a 2-D matrix is
produced.}

\item{feature_cols}{Character vector of feature column names. If \code{NULL},
all non-\code{exclude_cols} are used.}

\item{exclude_cols}{Columns to ignore entirely.}

\item{subjects}{Optional character vector specifying the ordering of the
\emph{Subject} dimension.}

\item{time_points}{Optional numeric / character vector giving the ordering
of the \emph{Time} dimension.}

\item{legacy_na}{Logical; if \code{TRUE}, forces \code{deduplicate = "first"} and
applies numeric coercion rules compatible with legacy code.}

\item{deduplicate}{Strategy when duplicate \verb{(id_col, time_col)} pairs are
found: \code{"first"}, \code{"last"}, or \code{"mean"}.}

\item{...}{Additional arguments passed on to the chosen helper.}

\item{x}{Either an object already in memory or a string path to a file.}

\item{mode}{Character; \code{"auto"}, \code{"never"}, or \code{"always"}.}

\item{header_in_row}{Logical; if \code{TRUE}, first transposed row ⇒ column
names.}
}
\value{
A 3-D numeric array with dimension names \emph{Subject}, \emph{Feature},
and \emph{Time}.

Either a 3-D numeric array or a 2-D numeric matrix.

A data.frame, matrix, list, or the original object, depending on
the input and file type.

A data.frame, transposed if criteria met, else the original \code{df}.
}
\description{
Converts a “long” data.frame with \strong{subject IDs}, \strong{time points} and
\strong{feature columns} into a numeric array whose dimensions are
\emph{Subject} × \emph{Feature} × \emph{Time}.

Dispatches to \code{.create_array3d()} when a valid \code{time_col} is provided and
present in \code{df};

Utility that detects whether \code{x} is a single-length character string
pointing to an existing file. If so, it loads the file using a reader
appropriate to the extension (\code{csv}, \code{tsv}, \code{rds}, \code{feather}, \code{parquet});
otherwise returns \code{x} untouched.

Decides—according to \code{mode} and the first column contents—whether to
transpose the input \code{df}. If \code{header_in_row = TRUE}, the first row after
transposition becomes the column names.
}
\details{
CSV/TSV are read with \code{read.csv()} / \code{read.delim()}.
RDS via \code{readRDS()}. Feather / Parquet require the \strong{arrow} package.
}
\examples{
# df must contain columns id, time, and features
arr <- .create_array3d(df, id_col = "ID", time_col = "T")
dim(arr)

tensor <- .build_tensor(df, id_col = "ID", time_col = "Time")

# If 'example.csv' exists it is read, otherwise the string is returned
.read_or_pass("example.csv")

df <- data.frame(label = c("A","B"), x = 1:2, y = 3:4)
.transpose_if_needed(df, mode = "auto")

}
\keyword{internal}
